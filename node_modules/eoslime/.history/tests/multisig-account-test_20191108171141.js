const eoslime = require('./../').init();

describe('Multi signature account', function () {

    // Increase mocha(testing framework) time, otherwise tests fails
    this.timeout(15000);

    const FAUCET_ABI_PATH = "./tests/testing-contracts/compiled/faucet.abi";
    const FAUCET_WASM_PATH = "./tests/testing-contracts/compiled/faucet.wasm";

    let faucetContract;

    beforeEach(async () => {
        faucetContract = await eoslime.Contract.deploy(FAUCET_WASM_PATH, FAUCET_ABI_PATH);
    });

    describe.only('Multi signature transaction', function () {
        it('Should be signed by multiple accounts and be processed', async () => {
            const account = await eoslime.Account.createRandom();
            const accounts = await eoslime.Account.createRandoms(2);

            await account.addOnBehalfAccount(accounts[0].name);
            await account.addOnBehalfAccount(accounts[1].name);
            await account.increaseThreshold(2);

            const multiSigAccount = eoslime.MultiSigAccount.load(account.name, account.privateKey);
            multiSigAccount.loadAccounts(accounts);

            const proposalId = await multiSigAccount.propose(faucetContract.produce, [account.name, "100.0000 TKNS", account.name, "memo"]);
            await multiSigAccount.approve(multiSigAccount.accounts[0], proposalId)
            await multiSigAccount.processProposal(proposalId);

            console.log(await faucetContract.withdrawers.find());
        });

        it.only('Should be signed by multiple keys and be processed', async () => {
            const account = await eoslime.Account.createRandom();

            const keys = [
                await eoslime.utils.generateKeys(),
                await eoslime.utils.generateKeys()
            ]

            const multiSigAuth = await account.createAuthority('multisig');
            await multiSigAuth.addAuthorityKey(keys[0].publicKey)
            await multiSigAuth.addAuthorityKey(keys[1].publicKey)
            await multiSigAuth.increaseThreshold(2);

            await account.setAuthorityAbilities('multisig', [
                {
                    action: 'produce',
                    contract: faucetContract.name
                }
            ]);

            const multiSigAccount = eoslime.MultiSigAccount.load(account.name, account.privateKey);
            multiSigAccount.loadKeys(keys.map((key) => { return key.privateKey }));

            const proposalId = await multiSigAccount.propose(faucetContract.produce, [multiSigAccount.name, "100.0000 TKNS", multiSigAccount.name, "memo"])
            await multiSigAccount.approve(multiSigAccount.accounts[0], proposalId)
            await multiSigAccount.processProposal(proposalId);

            console.log(await faucetContract.withdrawers.find());
        });
    });
});
