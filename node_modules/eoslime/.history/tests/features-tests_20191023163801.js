const assert = require('assert');
const eoslime = require('./../').init();

const utils = require('./../src/utils');
const createAccountNameFromPublicKey = require('./../src/account/public-key-name-generator').createAccountNameFromPublicKey;

/*
    You should have running local nodeos in order to run tests
*/

describe.only('Features', function () {

    // Increase mocha(testing framework) time, otherwise tests fails
    this.timeout(15000);

    const FAUCET_ABI_PATH = "./tests/testing-contracts/compiled/faucet.abi";
    const FAUCET_WASM_PATH = "./tests/testing-contracts/compiled/faucet.wasm";

    //5KGaQ14gSZxhBeUz4AS6REkbZt5pakhoEhATupcWgHfdraoCycT
    const MSIG_ABI_PATH = "./tests/testing-contracts/compiled/eosio.msig.abi";
    const MSIG_WASM_PATH = "./tests/testing-contracts/compiled/eosio.msig.wasm";

    let faucetAccount;
    let faucetContract;
    let mutisigContract;

    beforeEach(async () => {
        try {
            faucetAccount = await eoslime.Account.createRandom();
            faucetContract = await eoslime.Contract.deployOnAccount(FAUCET_WASM_PATH, FAUCET_ABI_PATH, faucetAccount);
            // const multisigAccount = await eoslime.Account.load('eosio.msig', '5KTopL7p1PvvjfmXnRihzFmyGQbEbDPk3W5eouu5AGZfoEYommU')
            mutisigContract = await eoslime.Contract.deploy(MSIG_WASM_PATH, MSIG_ABI_PATH);
        } catch (error) {
            console.log(error);
        }
    });

    describe.only('Set authority abilities', function () {
        it('Should execute an action from custom authority', async () => {
            const account = await eoslime.Account.createRandom();
            const accounts = await eoslime.Account.createRandoms(2);
            const tokensReceiver = await eoslime.Account.createRandom()

            // const keysPair = await utils.generateKeys();
            // const secondAccount = eoslime.Account.load(account.name, keysPair.privateKey);
            await account.addOnBehalfAccount(accounts[0].name)
            await account.addOnBehalfAccount(accounts[1].name)
            await account.addOnBehalfAccount(mutisigContract.name, 'eosio.code', 2)
            await account.setThreshold(2);

            const multiSigAccount = await eoslime.Account.loadMultisig(account.name, accounts, account.privateKey, 'active')

            // mutisigContract = eoslime.Contract.fromFile(MSIG_ABI_PATH, 'eosio.msig', multisigAccount);

            const proposalData = await multiSigAccount.propose(mutisigContract, faucetAccount.name, 'produce', account.name, "100.0000 TKNS", account.name, "memo")

            await multiSigAccount.approveProposal(mutisigContract, accounts[0], 'produce')
            await multiSigAccount.approveProposal(mutisigContract, accounts[1], 'produce')
            await multiSigAccount.execProposal(mutisigContract, 'produce', accounts[0]);

            console.log(await faucetContract.getWithdrawers());

            // console.log(a)
        });

        it.only('Should execute an action from custom authority', async () => {
            const account = await eoslime.Account.createRandom();
            // await account.addOnBehalfAccount(mutisigContract.name, 'eosio.code', 2)


            const firstKey = await eoslime.utils.generateKeys();
            const secondKey = await eoslime.utils.generateKeys();
            const firstKeyAcc = eoslime.Account.load(account.name, firstKey.privateKey, 'multisig')
            const secondKeyAcc = eoslime.Account.load(account.name, secondKey.privateKey, 'multisig')
            const accounts = [firstKeyAcc, secondKeyAcc]

            const multiSigAuth = await account.createAuthority('multisig');
            await multiSigAuth.addAuthorityKey(firstKey.publicKey)
            await multiSigAuth.addAuthorityKey(secondKey.publicKey)
            await multiSigAuth.setThreshold(2);

            await account.setAuthorityAbilities('multisig', [
                {
                    action: 'produce',
                    contract: faucetAccount.name
                }
            ]);
            // const secondAccount = eoslime.Account.load(account.name, keysPair.privateKey);

            console.log((await multiSigAuth.getAuthorityInfo()).required_auth.keys)
            const multiSigAccount = await eoslime.Account.loadMultisig(firstKeyAcc.name, accounts, firstKeyAcc.privateKey, 'multisig')

            // mutisigContract = eoslime.Contract.fromFile(MSIG_ABI_PATH, 'eosio.msig', multisigAccount);


            const proposalData = await multiSigAccount.proposeKey(faucetAccount.name, 'produce', firstKeyAcc.name, "100.0000 TKNS", firstKeyAcc.name, "memo")
            console.log('here')
            await multiSigAccount.approveKey(accounts[1], faucetAccount.name, 'produce')
            // await multiSigAccount.approveKey(multiSigAuth, faucetAccount.name, 'produce')
            // await multiSigAccount.approveProposal(mutisigContract, accounts[1], 'produce')
            // console.log((await multiSigAuth.getAuthorityInfo()).required_auth.keys)
            await multiSigAccount.execKey(faucetAccount.name, 'produce');

            console.log(await faucetContract.getWithdrawers());

            // console.log(a)
        });
    });

    it('Should looks beatiful', async () => {

    });
});
