const assert = require('assert');
const eoslime = require('./../').init();
const proxyquire = require('proxyquire');

const ContractFactoryStub = require('./stubs/contract-factory-stub');

describe('Multi signature account', function () {

    // Increase mocha(testing framework) time, otherwise tests fails
    this.timeout(15000);

    const ACCOUNT_NAME = 'eosio';
    const ACCOUNT_PRIVATE_KEY = '5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3';

    const FAUCET_ABI_PATH = "./tests/testing-contracts/compiled/faucet.abi";
    const FAUCET_WASM_PATH = "./tests/testing-contracts/compiled/faucet.wasm";

    let faucetContract;

    beforeEach(async () => {
        faucetContract = await eoslime.Contract.deploy(FAUCET_WASM_PATH, FAUCET_ABI_PATH);
    });

    describe.only('Buy ram', function () {
        const EOSIO_SYSTEM_ABI_PATH = "./tests/testing-contracts/compiled/eosio.system.abi";
        const EOSIO_SYSTEM_WASM_PATH = "./tests/testing-contracts/compiled/eosio.system.wasm";

        let eosioSystemContract;

        /*
            Deploy eosio.system contract on local nodoes on custom contract in order to send eos and buy ram / bandwidth
        */
        async function deployEOSIOSystem() {
            eosioSystemContract = await eoslime.Contract.deploy(EOSIO_SYSTEM_WASM_PATH, EOSIO_SYSTEM_ABI_PATH);
        }

        before(async () => {
            await deployEOSIOSystem();
        });


        let MultiSignatureAccount;

        beforeEach(async () => {
            ContractFactoryStub.setContract(eosioSystemContract.name);
            MultiSignatureAccount = proxyquire('./../src/account/multi-signature-account/account', { '../../contract/contract-factory': ContractFactoryStub })
        });

        it('Should buy ram [payer]', async () => {
            const account = await eoslime.Account.createRandom();
            const accounts = await eoslime.Account.createRandoms(2);

            await account.addOnBehalfAccount(accounts[0].name);
            await account.addOnBehalfAccount(accounts[1].name);
            await account.setThreshold(2);

            const multiSigAccount = new MultiSignatureAccount(account.name, account.privateKey, eoslime.Provider, 'active');
            multiSigAccount.loadAccounts(accounts);

            const payer = eoslime.Account.load(ACCOUNT_NAME, ACCOUNT_PRIVATE_KEY);
            const tx = await multiSigAccount.buyRam(1000, payer);

            assert(tx.transaction.transaction.actions[0].name == 'buyrambytes', 'Incorrect buy ram transaction');
        });

        it.only('Should buy ram by self', async () => {
            const account = await eoslime.Account.createRandom();
            const accounts = await eoslime.Account.createRandoms(2);

            await account.addOnBehalfAccount(accounts[0].name);
            await account.addOnBehalfAccount(accounts[1].name);
            await account.setThreshold(2);

            const multiSigAccount = new MultiSignatureAccount(account.name, account.privateKey, eoslime.Provider, 'active');
            multiSigAccount.loadAccounts(accounts);

            const buyRamProposal = await multiSigAccount.buyRam(1000);
            await multiSigAccount.approve(multiSigAccount.accounts[0], buyRamProposal);
            const tx = await multiSigAccount.processProposal(buyRamProposal);
            // console.log(tx);
            // assert(tx.transaction.transaction.actions[0].name == 'buyrambytes', 'Incorrect buy ram transaction');
        });

        it('Should throw if one provide incorrect account as ram payer', async () => {
            try {
                const account = await eoslime.Account.createRandom();
                const accounts = await eoslime.Account.createRandoms(2);

                await account.addOnBehalfAccount(accounts[0].name);
                await account.addOnBehalfAccount(accounts[1].name);
                await account.setThreshold(2);

                const multiSigAccount = new MultiSignatureAccount(account.name, account.privateKey, eoslime.Provider, 'active');
                multiSigAccount.loadAccounts(accounts);

                await multiSigAccount.buyRam(1000, 'Fake account');
                assert(false, 'Should throw');
            } catch (error) {
                assert(error.message.includes('Provided String is not an instance of Account'));
            }
        });

    });

    describe('Multi signature transaction', function () {
        it('Should be signed by multiple accounts and be processed', async () => {
            const account = await eoslime.Account.createRandom();
            const accounts = await eoslime.Account.createRandoms(2);

            await account.addOnBehalfAccount(accounts[0].name);
            await account.addOnBehalfAccount(accounts[1].name);
            await account.setThreshold(2);

            const multiSigAccount = eoslime.MultiSigAccount.load(account.name, account.privateKey);
            multiSigAccount.loadAccounts(accounts);

            const proposalId = await multiSigAccount.propose(faucetContract.produce, [account.name, "100.0000 TKNS", account.name, "memo"]);
            await multiSigAccount.approve(multiSigAccount.accounts[0], proposalId)
            await multiSigAccount.processProposal(proposalId);

            console.log(await faucetContract.withdrawers.find());
        });

        it('Should be signed by multiple keys and be processed', async () => {
            const account = await eoslime.Account.createRandom();

            const keys = [
                await eoslime.utils.generateKeys(),
                await eoslime.utils.generateKeys()
            ]

            const multiSigAuth = await account.createAuthority('multisig');
            await multiSigAuth.addAuthorityKey(keys[0].publicKey)
            await multiSigAuth.addAuthorityKey(keys[1].publicKey)
            await multiSigAuth.setThreshold(2);

            await account.setAuthorityAbilities('multisig', [
                {
                    action: 'produce',
                    contract: faucetContract.name
                }
            ]);

            const multiSigAccount = eoslime.MultiSigAccount.load(account.name, account.privateKey);
            multiSigAccount.loadKeys(keys.map((key) => { return key.privateKey }));

            const proposalId = await multiSigAccount.propose(faucetContract.produce, [multiSigAccount.name, "100.0000 TKNS", multiSigAccount.name, "memo"])

            await multiSigAccount.approve(multiSigAccount.accounts[0], proposalId)
            await multiSigAccount.processProposal(proposalId);

            console.log(await faucetContract.withdrawers.find());
        });
    });
});
