const assert = require('assert');
const eoslime = require('./../');
const eoslimeTool = eoslime.init();

const Account = eoslimeTool.Account;
const Provider = eoslimeTool.Provider;

const utils = require('./../src/utils');
const createAccountNameFromPublicKey = require('./../src/account/public-key-name-generator').createAccountNameFromPublicKey;

/*
    You should have running local nodeos in order to run tests
*/

describe.only('Features', function () {

    // Increase mocha(testing framework) time, otherwise tests fails
    this.timeout(15000);

    const ACCOUNT_NAME = 'eosio';
    const EXECUTIVE_AUTHORITY = {
        actor: 'eosio',
        permission: 'active'
    }
    const ACCOUNT_PRIVATE_KEY = '5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3';
    const ACCOUNT_PUBLIC_KEY = 'EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV';

    /*
        Deploy eos token contract on local nodoes in order to send eos and buy ram / bandwidth
    */
    async function createEOSToken() {
        const TOKEN_ABI_PATH = './example/eosio-token/contract/eosio.token.abi';
        const TOKEN_WASM_PATH = './example/eosio-token/contract/eosio.token.wasm';
        const TOTAL_SUPPLY = '1000000000.0000 SYS';

        // Creates eosio.token account if you don't have it
        try {
            const tokenAccount = await Account.createFromName('eosio.token');
            const tokenContract = await eoslimeTool.Contract.deployOnAccount(TOKEN_WASM_PATH, TOKEN_ABI_PATH, tokenAccount);
            await tokenContract.create(tokenAccount.name, TOTAL_SUPPLY);
            await tokenContract.issue(ACCOUNT_NAME, TOTAL_SUPPLY, 'memo');
        } catch (error) {
        }
    }

    before(async () => {
        await createEOSToken();
    });

    function assertCorrectAccount(account) {
        assert(account.name == ACCOUNT_NAME, 'Incorrect name');
        assert(account.privateKey == ACCOUNT_PRIVATE_KEY, 'Incorrect private key');
        assert(account.publicKey == ACCOUNT_PUBLIC_KEY, 'Incorrect public key');
        assert(account.executiveAuthority.actor == EXECUTIVE_AUTHORITY.actor, 'Incorrect executive authority actor');
        assert(account.executiveAuthority.permission == EXECUTIVE_AUTHORITY.permission, 'Incorrect executive authority permission');

        const network = account.provider.network;
        assert(JSON.stringify(account.provider.network) == JSON.stringify(Networks[network.name]))
    }


    describe.only('Set authority abilities', function () {
        it('Should set authority abilities', async () => {
            const THRESHOLD = 2;
            const account = await Account.createRandom();

            const customAccount = await account.createAuthority('custom');
            await customAccount.setAuthorityAbilities([
                {
                    action: 'minttokens',
                    contract: 'faucetcontra'
                    // contract: faucetContract.name
                }
            ]);

            console.log(await eoslimeTool.Provider.eos.getAccount(account.name));
        });

        it.only('Should execute an action from custom authority', async () => {
            const account = await Account.createRandom();
            const tokensReceiver = await Account.createRandom()

            const keysPair = await utils.generateKeys();
            const secondAccount = Account.load(account.name, keysPair.privateKey);
            await account.addAuthorityKey(keysPair.publicKey)
            await account.setThreshold(2);

            const multiSigAccount = await Account.loadMultisig(account.name, [secondAccount], account.privateKey, 'active')
            const a = await multiSigAccount.propose('eosio.token', 'transfer', multiSigAccount.name, tokensReceiver.name, '100 EOS')
            console.log(a)
        });

        it('Should throw if one does not provide array as abilities', async () => {

        });
    });

    const getAuthorityForAccount = async function (authorityName, accountName) {
        let accountInfo = await Provider.eos.getAccount(accountName);
        const authority = accountInfo.permissions.find((permission) => {
            return permission.perm_name == authorityName;
        });

        return authority;
    }
});
