const assert = require('assert');
const eoslime = require('./../');
const eoslimeTool = eoslime.init();

const Account = eoslimeTool.Account;
const Provider = eoslimeTool.Provider;

const utils = require('./../src/utils');
const createAccountNameFromPublicKey = require('./../src/account/public-key-name-generator').createAccountNameFromPublicKey;

/*
    You should have running local nodeos in order to run tests
*/

describe.only('Features', function () {

    // Increase mocha(testing framework) time, otherwise tests fails
    this.timeout(15000);

    const FAUCET_ABI_PATH = "./tests/testing-contracts/compiled/faucet.abi";
    const FAUCET_WASM_PATH = "./tests/testing-contracts/compiled/faucet.wasm";


    async function createEOSToken() {
        const TOKEN_ABI_PATH = './example/eosio-token/contract/eosio.token.abi';
        const TOKEN_WASM_PATH = './example/eosio-token/contract/eosio.token.wasm';
        const TOTAL_SUPPLY = '1000000000.0000 SYS';

        // Creates eosio.token account if you don't have it
        try {
            const tokenAccount = await Account.createFromName('eosio.token');
            const tokenContract = await eoslimeTool.Contract.deployOnAccount(TOKEN_WASM_PATH, TOKEN_ABI_PATH, tokenAccount);
            await tokenContract.create(tokenAccount.name, TOTAL_SUPPLY);
            await tokenContract.issue(ACCOUNT_NAME, TOTAL_SUPPLY, 'memo');
        } catch (error) {
            console.log(error)
        }
    }

    beforeEach(async () => {
        try {
            faucetAccount = await eoslime.Account.createRandom();
            await eoslime.Contract.deployOnAccount(FAUCET_WASM_PATH, FAUCET_ABI_PATH, faucetAccount);
        } catch (error) {
            console.log(error);
        }
    });

    describe.only('Set authority abilities', function () {
        it('Should execute an action from custom authority', async () => {
            const account = await Account.createRandom();
            const tokensReceiver = await Account.createRandom()

            const keysPair = await utils.generateKeys();
            const secondAccount = Account.load(account.name, keysPair.privateKey);
            await account.addAuthorityKey(keysPair.publicKey)
            await account.setThreshold(2);

            const multiSigAccount = await Account.loadMultisig(account.name, [secondAccount], account.privateKey, 'active')
            const a = await multiSigAccount.propose('eosio.token', 'transfer', multiSigAccount.name, tokensReceiver.name, '100 EOS')
            console.log(a)
        });
    });
});
