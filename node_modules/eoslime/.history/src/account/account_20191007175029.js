const is = require('../helpers/is')
const eosECC = require('eosjs').modules.ecc;

class Account {

    constructor(name, privateKey, provider, permission) {
        this.name = name;
        this.provider = provider;
        this.executiveAuthority = {
            actor: name,
            permission: permission
        }

        this.privateKey = privateKey;
        this.publicKey = eosECC.PrivateKey.fromString(privateKey).toPublic().toString();
    }

    async buyRam(bytes, payer = this) {
        is(payer).instanceOf(Account);

        return this.provider.eos.transaction(tr => {
            tr.buyrambytes({
                payer: payer.name,
                receiver: this.name,
                bytes: bytes
            });
        }, { keyProvider: payer.privateKey });
    }

    async buyBandwidth(cpu, net, payer = this) {
        is(payer).instanceOf(Account);

        return this.provider.eos.transaction(tr => {
            tr.delegatebw({
                from: payer.name,
                receiver: this.name,
                stake_cpu_quantity: cpu,
                stake_net_quantity: net,
                transfer: 0
            });
        }, { keyProvider: payer.privateKey });
    }

    async send(receiver, amount, symbol = 'EOS') {
        is(receiver).instanceOf(Account);

        return this.provider.eos.transfer(
            this.name,
            receiver.name,
            `${amount} ${symbol}`,
            this.executiveAuthority,
            { broadcast: true, sign: true, keyProvider: this.privateKey }
        );
    }

    async createAuthority(authorityName, threshold) {
        const authPrivateKey = await eosECC.randomKey();

        await this.provider.eos.transaction(tr => {
            tr.updateauth({
                account: this.name,
                permission: authorityName,
                parent: this.executiveAuthority.permission,
                auth: eosECC.PrivateKey.fromString(authPrivateKey).toPublic().toString()
            }, { authorization: [this.executiveAuthority] });

        }, { broadcast: true, sign: true, keyProvider: this.privateKey });

        return new Account(this.name, authPrivateKey, this.provider, authorityName);
    }

    async setAuthorityAbilities(abilities) {
        /*
            abilities => {
                [
                    action,
                    contractName
                ]
            }
        */

        // Todo: Check how keys are assigned
        for (let i = 0; i < abilities.length; i++) {
            const ability = abilities[i];

            await this.provider.eos.transaction(tr => {
                tr.linkauth({
                    account: this.name,
                    code: ability.contractName,
                    type: ability.action,
                    requirement: this.executiveAuthority
                }, { authorization: [this.executiveAuthority] });

            }, { broadcast: true, sign: true, keyProvider: this.privateKey });
        }
    }

    async addAuthorityKey(pubKey, weight) {
        const accountInfo = await this.provider.eos.getAccount(this.name);
        const authority = accountInfo.permissions.find((permission) => {
            return this.executiveAuthority.permission == permission.perm_name;
        });

        if (!authority) {
            throw new Error('Could not add permission to non-existing authority');
        }

        // Todo: should console it
        const hasAlreadyPermission = authority.required_auth.accounts.find((account) => {
            return account.permission.permission == permName;
        });

        if (!hasAlreadyPermission) {
            authority.required_auth.keys.push({ key, weight: 1 });

            return this.provider.eos.transaction(tr => {
                tr.updateauth({
                    account: this.name,
                    permission: authority.perm_name,
                    parent: authority.parent,
                    auth: authority.required_auth
                }, { authorization: [this.executiveAuthority] });

            }, { broadcast: true, sign: true, keyProvider: this.privateKey });
        }
    }

    async addAuthorityActor(actor, weight) {
        const accountInfo = await this.provider.eos.getAccount(this.name);
        const authority = accountInfo.permissions.find((permission) => {
            return this.executiveAuthority.permission == permission.perm_name;
        });

        if (!authority) {
            throw new Error('Could not add permission to non-existing authority');
        }

        const hasAlreadyPermission = authority.required_auth.accounts.find((account) => {
            return account.permission.permission == permName;
        });

        if (!hasAlreadyPermission) {
            authority.required_auth.accounts.push({ permission: { actor: actor, permission: permName }, weight: 1 });

            return this.provider.eos.transaction(tr => {
                tr.updateauth({
                    account: this.name,
                    permission: authority.perm_name,
                    parent: authority.parent,
                    auth: authority.required_auth
                }, { authorization: [this.executiveAuthority] });

            }, { broadcast: true, sign: true, keyProvider: this.privateKey });
        }
    }

    async setThreshold(threshold) {
        const accountInfo = await this.provider.eos.getAccount(this.name);
        const authority = accountInfo.permissions.find((permission) => {
            return account.executiveAuthority.permission == permission.perm_name;
        });

        if (!authority) {
            throw new Error('Could not add permission to non-existing authority');
        }

        const hasAlreadyPermission = authority.required_auth.accounts.find((account) => {
            return account.permission.permission == permName;
        });

        if (!hasAlreadyPermission) {
            return this.provider.eos.transaction(tr => {
                tr.updateauth({
                    account: this.name,
                    permission: authority.perm_name,
                    parent: authority.parent,
                    auth: {
                        threshold,
                        ...authority.required_auth
                    }
                }, { authorization: [this.executiveAuthority] });

            }, { broadcast: true, sign: true, keyProvider: this.privateKey });
        }
    }

    // async addPermission(permName, actor = this.name) {
    //     const accountInfo = await this.provider.eos.getAccount(this.name);
    //     const authority = accountInfo.permissions.find((permission) => {
    //         return this.executiveAuthority.permission == permission.perm_name;
    //     });

    //     if (!authority) {
    //         throw new Error('Could not add permission to non-existing authority');
    //     }

    //     const hasAlreadyPermission = authority.required_auth.accounts.find((account) => {
    //         return account.permission.permission == permName;
    //     });

    //     if (!hasAlreadyPermission) {
    //         authority.required_auth.accounts.push({ permission: { actor: actor, permission: permName }, weight: 1 });

    //         return this.provider.eos.transaction(tr => {
    //             tr.updateauth({
    //                 account: this.name,
    //                 permission: authority.perm_name,
    //                 parent: authority.parent,
    //                 auth: authority.required_auth
    //             }, { authorization: [this.executiveAuthority] });

    //         }, { broadcast: true, sign: true, keyProvider: this.privateKey });
    //     }
    // }

    async getBalance(symbol = 'EOS', code = 'eosio.token') {
        return this.provider.eos.getCurrencyBalance(code, this.name, symbol);
    }
}

const getAuthorityFromBlockchain = async function () {
    const accountInfo = await this.provider.eos.getAccount(this.name);
    const authority = accountInfo.permissions.find((permission) => {
        return account.executiveAuthority.permission == permission.perm_name;
    });

    if (!authority) {
        throw new Error('Could not add permission to non-existing authority');
    }
}

module.exports = Account;
