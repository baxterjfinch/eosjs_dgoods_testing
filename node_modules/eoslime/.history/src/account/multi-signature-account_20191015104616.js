const is = require('../helpers/is')
const BaseAccount = require('./base-account');

class MultiSignatureAccount extends BaseAccount {

    constructor(name, privateKey, provider, authority, accounts) {
        super(name, privateKey, provider, authority)

        this.accounts = []
        for (let i = 0; i < accounts.length; i++) {
            is(accounts[i]).instanceOf(BaseAccount)
            this.accounts.push(accounts[i])
        }
    }

    async buyRam(bytes, payer = this) {
        throw new Error('Abstract class')
    }

    async buyBandwidth(cpu, net, payer = this) {
        throw new Error('Abstract class')
    }

    async send(receiver, amount, symbol = 'EOS') {
        throw new Error('Abstract class')
    }

    async createAuthority(authorityName, threshold = 1) {
        throw new Error('Abstract class')
    }

    async setAuthorityAbilities(abilities) {
        throw new Error('Abstract class')
    }

    async setThreshold(threshold) {
        throw new Error('Abstract class')
    }

    async getAuthorityInfo() {
        throw new Error('Abstract class')
    }

    async addPermission(authorityName, weight = 1) {
        throw new Error('Abstract class')
    }

    async addOnBehalfAccount(accountName, authorityName, weight = 1) {
        throw new Error('Abstract class')
    }

    async addAuthorityKey(publicKey, weight = 1) {
        throw new Error('Abstract class')
    }

    async setWeight() {
        throw new Error('Abstract class')
    }

    async getBalance(symbol = 'EOS', code = 'eosio.token') {
        throw new Error('Abstract class')
    }

    addProposerAccount(account) {
        is(account).instanceOf(BaseAccount)
        this.proposers.push(account)
    }

    // async propose(action, proposer) {
    //     const accountInfo = await this.getAuthorityInfo();
    //     const proposalData =
    //     {
    //         proposer: proposer,
    //         proposal_name: action,
    //         requested: [
    //             {
    //                 actor: proposer.actor,
    //                 permission: proposer.permission
    //             },
    //             {
    //                 actor: 'bob',
    //                 permission: 'active'
    //             }
    //         ]
    //     }

    //     await this.provider.eos.transact({
    //         actions: [{
    //             account: 'eosio.msig',
    //             name: 'propose',
    //             authorization: [{
    //                 actor: proposer.actor,
    //                 permission: proposer.permission,
    //             }],
    //             data: proposalData,
    //         }]
    //     });
    // }

    approveProposal(approver, proposal) {
        is(approver).instanceOf(BaseAccount)

    }

    async propose(proposer, contractName, action, ...actionData) {
        const accountInfo = await this.getAuthorityInfo();
        // const contractInstance = await ContractFactory.at(contractName, proposer)
        const actionTx = await utils.generateTransaction(contractName, action, ...actionData)
        // const actionTx = await contractInstance[action](...actionData, { broadcast: false, sign: false })

        const proposalData =
        {
            proposer: proposer,
            proposal_name: action,
            requested: [
                {
                    actor: proposer.actor,
                    permission: proposer.permission
                },
                {
                    actor: 'bob',
                    permission: 'active'
                }
            ]
        }

        await this.provider.eos.transact({
            actions: [{
                account: 'eosio.msig',
                name: 'propose',
                authorization: [{
                    actor: proposer.actor,
                    permission: proposer.permission,
                }],
                data: proposalData,
            }]
        });
    }
}



module.exports = MultiSignatureAccount
