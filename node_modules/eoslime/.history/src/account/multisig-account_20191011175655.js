class MultiSigAccount {
    constructor(name, provider, privateKey, authority) {
        this.name = name;
        this.provider = provider;
        this.proposers = [{
            actor: name,
            permission: permission
        }]
    }

    // eoslime.LocalProvider.enableMultiSignature()

    addProposerAccount(account) {
        this.proposers.push({
            actor: account.executiveAuthority.actor,
            permission: account.executiveAuthority.permission
        })
    }

    async propose(action, proposer) {
        const accountInfo = await this.getAuthorityInfo();
        const proposalData =
        {
            proposer: proposer,
            proposal_name: action,
            requested: [
                {
                    actor: 'alice',
                    permission: 'active'
                },
                {
                    actor: 'bob',
                    permission: 'active'
                }
            ]
        }

        await this.provider.eos.transact({
            actions: [{
                account: 'eosio.msig',
                name: 'propose',
                authorization: [{
                    actor: proposer.actor,
                    permission: proposer.permission,
                }],
                data: actionData,
            }]
        });
    }

    async getAuthorityInfo() {
        const accountInfo = await this.provider.eos.getAccount(this.name);
        const authorityInfo = accountInfo.permissions.find((permission) => {
            return this.executiveAuthority.permission == permission.perm_name;
        });

        if (!authorityInfo) {
            throw new Error('Could not find such authority on chain');
        }

        return authorityInfo;
    }

    approveProposal() {

    }
}

module.exports = MultiSigAccount;
