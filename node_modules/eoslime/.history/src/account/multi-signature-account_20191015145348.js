const is = require('../helpers/is')
const utils = require('../utils/index')
const BaseAccount = require('./base-account');

class MultiSignatureAccount extends BaseAccount {

    constructor(name, privateKey, provider, authority, accounts) {
        super(name, privateKey, provider, authority)

        this.accounts = []
        for (let i = 0; i < accounts.length; i++) {
            is(accounts[i]).instanceOf(BaseAccount)
            this.accounts.push(accounts[i])
        }
    }

    async buyRam(bytes, payer = this) {
        this.propose();
    }

    async buyBandwidth(cpu, net, payer = this) {
        this.propose();
    }

    async send(receiver, amount, symbol = 'EOS') {
        this.propose();
    }

    async createAuthority(authorityName, threshold = 1) {
        this.propose();
    }

    async setAuthorityAbilities(abilities) {
        this.propose();
    }

    async setThreshold(threshold) {
        this.propose();
    }

    async addPermission(authorityName, weight = 1) {
        this.propose();
    }

    async addOnBehalfAccount(accountName, authorityName, weight = 1) {
        this.propose();
    }

    async addAuthorityKey(publicKey, weight = 1) {
        this.propose();
    }

    async setWeight() {
        this.propose();
    }

    addProposerAccount(account) {
        is(account).instanceOf(BaseAccount)
        this.proposers.push(account)
    }

    // Todo: check if proposal name is actually 12 symbol EOS account name
    // proposer is this.privateKey
    async propose(contractName, action, ...actionData) {
        const accountInfo = await this.getAuthorityInfo();

        const contractInstance = await ContractFactory.at(contractName, proposer);
        const actionTx = await utils.getRawTransaction(contractInstance, action, ...actionData);

        await executeMultiSignatureAction.call(this, 'propose', {
            proposer: this.name,
            proposal_name: 'Proposal name',
            requested: accountInfo,
            trx: actionTx
        });

        // const msigContract = getLazyMSigContractInstance();
        // await msigContract.propose(this.name, proposal Name, [accountInfo.required_auth], actionTx)

        // await this.provider.eos.transact({
        //     actions: [{
        //         account: 'eosio.msig',
        //         name: 'propose',
        //         authorization: [{
        //             actor: proposer.actor,
        //             permission: proposer.permission,
        //         }],
        //         data: {
        //             proposer: proposer.name,
        //         },
        //     }]
        // });
    }

    // Check if it works, cus there should have proposal hash
    approveProposal(approver, proposalName) {
        is(approver).instanceOf(BaseAccount)

        await executeMultiSignatureAction.call(this, 'approve', {
            proposer: approve.name,
            proposal_name: proposalName,
            level: approver.executiveAuthority.permission,
        });
    }

    disapproveProposal(approver, proposalName) {
        is(approver).instanceOf(BaseAccount)

        await executeMultiSignatureAction.call(this, 'unapprove', {
            proposer: approver.name,
            proposal_name: proposalName,
            level: approver.executiveAuthority.permission,
        });
    }

    execProposal(proposalName, executor = this) {
        is(executor).instanceOf(BaseAccount)

        await executeMultiSignatureAction.call(this, 'exec', {
            proposer: this.name,
            proposal_name: 'Proposal name',
            requested: accountInfo,
            trx: actionTx
        })
    }

    cancelProposal(proposalName, canceler = this) {
        is(executor).instanceOf(BaseAccount);

        await executeMultiSignatureAction.call(this, 'exec', {
            proposer: this.name,
            proposal_name: 'Proposal name',
            requested: accountInfo,
            trx: actionTx
        });

        const msigContract = getLazyMSigContractInstance();
        await msigContract.exec(this.name, proposalName, canceler.name, { from: canceler })
    }

}

const executeMultiSignatureAction = async function (actionName, actionParams) {
    return this.provider.eos.transact({
        actions: [{
            account: 'eosio.msig',
            name: actionName,
            authorization: [{
                actor: this.executiveAuthority.actor,
                permission: this.executiveAuthority.permission,
            }],
            data: actionParams,
        }]
    });
}

module.exports = MultiSignatureAccount
