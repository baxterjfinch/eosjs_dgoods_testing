const is = require('../helpers/is')
const utils = require('../utils/index')
const BaseAccount = require('./base-account');

class MultiSignatureAccount extends BaseAccount {

    constructor(name, privateKey, provider, authority, accounts) {
        super(name, privateKey, provider, authority)

        this.accounts = []
        for (let i = 0; i < accounts.length; i++) {
            is(accounts[i]).instanceOf(BaseAccount)
            this.accounts.push(accounts[i])
        }
    }

    async buyRam(bytes, payer = this) {
        this.propose();
    }

    async buyBandwidth(cpu, net, payer = this) {
        this.propose();
    }

    async send(receiver, amount, symbol = 'EOS') {
        this.propose();
    }

    async createAuthority(authorityName, threshold = 1) {
        this.propose();
    }

    async setAuthorityAbilities(abilities) {
        this.propose();
    }

    async setThreshold(threshold) {
        this.propose();
    }

    async addPermission(authorityName, weight = 1) {
        this.propose();
    }

    async addOnBehalfAccount(accountName, authorityName, weight = 1) {
        this.propose();
    }

    async addAuthorityKey(publicKey, weight = 1) {
        this.propose();
    }

    async setWeight() {
        this.propose();
    }

    addProposerAccount(account) {
        is(account).instanceOf(BaseAccount)
        this.proposers.push(account)
    }

    // proposer is this.privateKey
    async propose(msig, contractName, action, ...actionData) {
        const ContractFactory = require('./../contract/contract-factory');
        const contractFactory = new ContractFactory(this.provider)
        const contractInstance = await contractFactory.at(contractName, this);
        const actionTx = await contractInstance[action].getRawTransaction(...actionData);
        const accountInfo = await this.getAuthorityInfo();
        const requested = [];
        for (let i = 0; i < accountInfo.required_auth.accounts.length; i++) {
            requested.push(accountInfo.required_auth.accounts[i].permission)
        }

        const proposalName = await utils.randomName();
        // Proposal name is actually account name

        // console.log(actionTx)
        actionTx.max_net_usage_words = 0
        await msig.propose(this.accounts[0].name, action, requested, actionTx, { from: this.accounts[0] })
        // const a = await executeMultiSignatureAction.call(this, 'propose', {
        //     proposer: this.accounts[0].name,
        //     proposal_name: proposalName,
        //     requested: requested,
        //     trx: actionTx
        // }, this.accounts[0]);

        return proposalName
    }

    async proposeKey(msig, contractName, action, ...actionData) {
        const ContractFactory = require('./../contract/contract-factory');
        const contractFactory = new ContractFactory(this.provider)
        const contractInstance = await contractFactory.at(contractName, this);
        const actionTx = await contractInstance[action].getRawTransaction(...actionData);
        const accountInfo = await this.getAuthorityInfo();
        const requested = [];
        for (let i = 0; i < accountInfo.required_auth.keys.length; i++) {
            console.log(accountInfo.required_auth.keys[i])
            requested.push(accountInfo.required_auth.keys[i].key)
        }

        const proposalName = await utils.randomName();
        // Proposal name is actually account name

        // console.log(actionTx)
        actionTx.max_net_usage_words = 0
        await msig.propose(this.accounts[0].name, action, requested, actionTx, { from: this.accounts[0] })
        // const a = await executeMultiSignatureAction.call(this, 'propose', {
        //     proposer: this.accounts[0].name,
        //     proposal_name: proposalName,
        //     requested: requested,
        //     trx: actionTx
        // }, this.accounts[0]);

        return proposalName
    }

    // Check if it works, cus there should have proposal hash
    async approveProposal(msig, approver, proposalName) {
        is(approver).instanceOf(BaseAccount)
        await msig.approve(this.accounts[0].name, proposalName, approver.executiveAuthority, { from: approver })
        // await executeMultiSignatureAction.call(this, 'approve', {
        //     proposer: approver.name,
        //     proposal_name: proposalName,
        //     level: approver.executiveAuthority,
        // }, approver);
    }

    async disapproveProposal(disapprover, proposalName) {
        is(disapprover).instanceOf(BaseAccount);

        await executeMultiSignatureAction.call(this, 'unapprove', {
            proposer: disapprover.name,
            proposal_name: proposalName,
            level: disapprover.executiveAuthority.permission,
        });
    }

    // Todo: add sleep in order to get result after deffered tx is executed
    async execProposal(msig, proposalName, executor = this) {
        is(executor).instanceOf(BaseAccount);

        return new Promise(async (resolve, reject) => {
            const execTx = await msig.exec(this.accounts[0].name, proposalName, executor.name, { from: executor })

            setTimeout(() => {
                resolve(execTx);
            }, 600)
        });


        // await executeMultiSignatureAction.call(this, 'exec', {
        //     proposer: this.accounts[0].name,
        //     proposal_name: proposalName,
        //     executer: this.accounts[0].name
        // }, this.accounts[0]);
    }

    async cancelProposal(proposalName, canceler = this) {
        is(executor).instanceOf(BaseAccount);

        await executeMultiSignatureAction.call(this, 'cancel', {
            proposer: this.name,
            proposal_name: proposalName,
            canceler: canceler.name,
        });
    }
}

const executeMultiSignatureAction = async function (actionName, actionParams, signer) {
    return this.provider.eos.transaction({
        actions: [{
            account: 'eosio.msig',
            name: actionName,
            authorization: [{
                actor: signer.executiveAuthority.actor,
                permission: signer.executiveAuthority.permission,
            }],
            data: actionParams,
        }]
    }, { broadcast: true, sign: true, keyProvider: signer.privateKey });
}

module.exports = MultiSignatureAccount
