const is = require('../helpers/is')
const eosECC = require('eosjs').modules.ecc;

class BaseAccount {
    constructor(name, privateKey, provider, permission) {
        this.name = name;
        this.provider = provider;
        this.executiveAuthority = {
            actor: name,
            permission: permission
        }

        this.privateKey = privateKey;
        this.publicKey = eosECC.PrivateKey.fromString(privateKey).toPublic().toString();
    }

    async buyRam(bytes, payer = this) {
        throw new Error('Abstract class')
    }

    async buyBandwidth(cpu, net, payer = this) {
        throw new Error('Abstract class')
    }

    async send(receiver, amount, symbol = 'EOS') {
        throw new Error('Abstract class')
    }

    async createAuthority(authorityName, threshold = 1) {
        throw new Error('Abstract class')
    }

    async setAuthorityAbilities(abilities) {
        throw new Error('Abstract class')
    }

    async setThreshold(threshold) {
        throw new Error('Abstract class')
    }

    async getAuthorityInfo() {
        const accountInfo = await this.provider.eos.getAccount(this.name);
        const authorityInfo = accountInfo.permissions.find((permission) => {
            return this.executiveAuthority.permission == permission.perm_name;
        });

        if (!authorityInfo) {
            throw new Error('Could not find such authority on chain');
        }

        return authorityInfo;
    }


    async addPermission(authorityName, weight = 1) {
        throw new Error('Abstract class')
    }

    async addOnBehalfAccount(accountName, authorityName, weight = 1) {
        throw new Error('Abstract class')
    }

    async addAuthorityKey(publicKey, weight = 1) {
        throw new Error('Abstract class')
    }

    async setWeight() {
        throw new Error('Abstract class')
    }

    async getBalance(symbol = 'EOS', code = 'eosio.token') {
        return this.provider.eos.getCurrencyBalance(code, this.name, symbol);
    }
}

module.exports = BaseAccount
