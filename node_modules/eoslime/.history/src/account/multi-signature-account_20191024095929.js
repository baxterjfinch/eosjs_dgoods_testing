const is = require('../helpers/is')
const utils = require('../utils/index')
const BaseAccount = require('./base-account');

class MultiSignatureAccount extends BaseAccount {

    constructor(name, privateKey, provider, authority) {
        super(name, privateKey, provider, authority)

        this.accounts = [];
        this.contracts = {};
        this.proposals = {};
    }

    async buyRam(bytes, payer = this) {
        this.propose();
    }

    async buyBandwidth(cpu, net, payer = this) {
        this.propose();
    }

    async send(receiver, amount, symbol = 'EOS') {
        this.propose();
    }

    async createAuthority(authorityName, threshold = 1) {
        this.propose();
    }

    async setAuthorityAbilities(abilities) {
        this.propose();
    }

    async setThreshold(threshold) {
        this.propose();
    }

    async addPermission(authorityName, weight = 1) {
        this.propose();
    }

    async addOnBehalfAccount(accountName, authorityName, weight = 1) {
        this.propose();
    }

    async addAuthorityKey(publicKey, weight = 1) {
        this.propose();
    }

    async setWeight() {
        this.propose();
    }

    // should return proposal id in order to skip everytime contract name and action
    async propose(contractAction, actionData) {
        const actionTx = await contractAction.getSignedTransaction(this, ...actionData);
        const proposalId = hash(actionData);

        this.proposals[proposalId] = actionTx;
        this.proposalsActions[proposalId] = { action: contractAction, data: actionData };

        return proposalId;
    }

    async approve(approver, proposalId) {
        is(approver).instanceOf(BaseAccount);
        if (!this.proposals[proposalId]) {
            throw new Error('Such proposal does not exists');
        }

        const proposalAction = this.proposalsActions[proposalId];
        const actionTx = await proposalAction.action.getSignedTransaction(approver, ...proposalAction.data);

        this.proposals[proposalId].signatures.push(actionTx.signatures[0]);
    }

    async approveAll(proposalId) {
        for (let i = 0; i < this.accounts.length; i++) {
            await this.approve(this.accounts[i], proposalId);
        }
    }

    async processProposal(contractName, actionName) {
        if (!this.proposals[contractName]) {
            throw new Error('Such proposal does not exists')
        }

        const proposalTx = this.proposals[contractName][actionName];
        return pushMultiSignatureTransaction.call(this, proposalTx)
    }

    async disapproveProposal(disapprover, proposalName) {
        is(disapprover).instanceOf(BaseAccount);

        await executeMultiSignatureAction.call(this, 'unapprove', {
            proposer: disapprover.name,
            proposal_name: proposalName,
            level: disapprover.executiveAuthority.permission,
        });
    }



    async cancelProposal(proposalName, canceler = this) {
        is(executor).instanceOf(BaseAccount);

        await executeMultiSignatureAction.call(this, 'cancel', {
            proposer: this.name,
            proposal_name: proposalName,
            canceler: canceler.name,
        });
    }
}


const pushMultiSignatureTransaction = async function (signedRawTx) {
    // return this.provider.eos.transaction(signedRawTx, { broadcast: true });
    return this.provider.eos.pushTransaction(signedRawTx);
}

const executeMultiSignatureAction = async function (actionName, actionParams, signer) {
    return this.provider.eos.transaction({
        actions: [{
            account: 'eosio.msig',
            name: actionName,
            authorization: [{
                actor: signer.executiveAuthority.actor,
                permission: signer.executiveAuthority.permission,
            }],
            data: actionParams,
        }]
    }, { broadcast: true, sign: true, keyProvider: signer.privateKey });
}

module.exports = MultiSignatureAccount
